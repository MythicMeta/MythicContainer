package loggingstructs

import (
	"encoding/json"
	"github.com/MythicMeta/MythicContainer/logging"
	"github.com/MythicMeta/MythicContainer/utils/sharedStructs"
	"time"
)

type NewPayloadLog struct {
	loggingMessageBase
	Data NewPayloadLogData `json:"data"`
}
type NewPayloadLogData struct {
	ID               int       `json:"id"`
	UUID             string    `json:"uuid"`
	Description      string    `json:"description"`
	OperatorID       int       `json:"operator_id"`
	CreationTime     time.Time `json:"creation_time"`
	PayloadTypeID    int       `json:"payload_type_id"`
	OperationID      int       `json:"operation_id"`
	WrappedPayloadID *int      `json:"wrapped_payload_id"`
	Deleted          bool      `json:"deleted"`
	BuildContainer   string    `json:"build_container"`
	BuildPhase       string    `json:"build_phase"`
	BuildMessage     string    `json:"build_message"`
	BuildStderr      string    `json:"build_stderr"`
	BuildStdout      string    `json:"build_stdout"`
	CallbackAlert    bool      `json:"callback_alert"`
	AutoGenerated    bool      `json:"auto_generated"`
	OS               string    `json:"os"`
	TaskID           *int      `json:"task_id"`
	FileID           *int      `json:"file_id"`
	Timestamp        time.Time `json:"timestamp"`
}

func init() {
	AllLoggingData.Get("").AddDirectMethod(sharedStructs.RabbitmqDirectMethod{
		RabbitmqRoutingKey:         LOG_TYPE_PAYLOAD,
		RabbitmqProcessingFunction: processNewPayloadLog,
	})
}

func processNewPayloadLog(input []byte) {
	inputStruct := NewPayloadLog{}
	if err := json.Unmarshal(input, &inputStruct); err != nil {
		logging.LogError(err, "Failed to process message")
	} else {
		for _, webhook := range AllLoggingData.GetAllNames() {
			if AllLoggingData.Get(webhook).GetLoggingDefinition().NewPayloadFunction != nil {
				AllLoggingData.Get(webhook).GetLoggingDefinition().NewPayloadFunction(inputStruct)
			}
		}
	}
}
